---
title: "Report of the lonely cluster results"
author: "Ellis Franklin"
date: last-modified
date-format: iso 
theme: "flatly"
highlight-style: "breeze"
toc: true
number-sections: true
number-depth: 2
format: 
  html: 
    embed-resources: true
    self-contained: true
    grid: 
      margin-width: 200px
      sidebar-width: 100px
execute: 
  warning: false
reference-location: margin
citation-location: margin
editor: visual
cap-location: margin
output-file: "lonely_results_report_sc09_cf4_2024-05-13.html"
---

```{r}
#| label: load-fun-data
#| include: false

### Load everything : from packages to functions to data ---------

knitr::opts_chunk$set(warning = F, message = F)
options(scipen = 1, digits = 2) 

## Packages required ---------
require(ggplot2)
require(kableExtra)
require(DT)

## Function for specific cluster info retrieval ---------
retrieve_info_for <- function(number) {
  
  # Cluster id and first quartile associated
  cl_sens <- dnb_sens[number,]
  
  # Number of transcript within cluster
  ntranscript_sens <- lonelyfishing_data$dr_t_c_a_fishing[lonelyfishing_data$dr_t_c_a_fishing$new_clustr %in% as.character(cl_sens$groupby),]$id
  
  # Number of gene symbols within cluster
  ngene_sens <- lonelyfishing_data$dr_t_c_a_fishing[lonelyfishing_data$dr_t_c_a_fishing$new_clustr %in% as.character(cl_sens$groupby),]$external_gene_name
  
  # Driver GO terms
  go_sens <- subset(clustr_fusionres$dr_g_a_fusion, 
                      new_clustr == as.character(cl_sens$groupby) & source == "GO:BP")
  
  # KEGG pathways
  kegg_sens <- subset(clustr_fusionres$dr_g_a_fusion, 
                        new_clustr == as.character(cl_sens$groupby) & source == "KEGG")
  
  # Wikipathways
  wp_sens <- subset(clustr_fusionres$dr_g_a_fusion, 
                      new_clustr == as.character(cl_sens$groupby) & source == "WP")
  
  biglist <- list(cl_sens = cl_sens,
                  ntranscript_sens = ntranscript_sens,
                  ngene_sens = ngene_sens,
                  go_sens = go_sens,
                  kegg_sens = kegg_sens,
                  wp_sens = wp_sens)
  
  return(biglist)
}


### Load Project Addins (R Functions and Packages) ------
devtools::load_all(here::here())

## Load DRomics drcfit object (which holds the background transcript list) 
f <- readRDS(file = here::here("data", "raw-data", "fitres_zebrafish_phtalate.rds"))
## Load DRomics bmdboot object
b <- readRDS(file = here::here("data", "raw-data", "bootres_zebrafish_phtalate_UF_seed3_5000iter.rds"))

## We filter the bmdboot result by selecting only transcripts with a defined confidence interval around the BMD
BMDres_definedCI <- DRomics::bmdfilter(b$res, BMDfilter = "definedCI")

## Retrieve the background identifiers
bg_t_ids <- read.table(here::here("outputs", "bg_t_ids_2024-05-02.txt"))

## Retrieve the deregulated identifiers
dr_t_ids <- bg_t_ids[bg_t_ids$ensembl_transcript_id_version %in% BMDres_definedCI$id,]

## Retrieve the getclustrs() output
dr_g_string_clustr <- read.csv(here::here("outputs", "cytoscape-files", "Resp_PPIN_clustered_cs09_mcl4_2023-10-05.csv"))

## Reformat the query term column by removing STRING identifiers from gene names (e.g., "\"ENSDARG00000042520\"" -> "ENSDARG00000042520")
dr_g_string_clustr$query.term <- stringr::str_replace_all(dr_g_string_clustr$query.term, "\"", "")
  
## Create a dataframe for seamless merge with the 'getregs_data' dataframe
dr_g_string_clustr <- data.frame(ensembl_gene_id = dr_g_string_clustr$query.term, 
                                   clustr = dr_g_string_clustr$X__mclCluster)
  
## Create a 'clustr_data' dataframe similar to 'getregs_data' but with an added cluster ID column. This allows us to have dose-response modelling metrics to illustrate the PPIN network
dr_t_clustr_data <- merge(dr_t_ids, dr_g_string_clustr, by = "ensembl_gene_id")
  
## Remove genes not associated with a cluster 
dr_t_clustr_data <- subset(dr_t_clustr_data, !is.na(clustr)) 

## Retrieve the clustrfiltr() output
sizelimit <- 4

dr_t_clustrs_filtr <- clustrfiltr(
  getclustrs_data = dr_t_clustr_data,
  size_filtr = sizelimit
)

## Retrieve the clustr_enrichres 
clustr_enrichres <- readRDS(here::here("outputs", "cs09-cf4", "clustr_enrichres_cs09_cf4_2024-05-13.rds"))

## Retrieve the  clustr_fusionres
clustr_fusionres <- clustrfusion(
  clustrenrich_data = clustr_enrichres
)

## Load the workflow results 
lonelyfishing_data <- readRDS(here::here("outputs", "cs09-cf4", "lonely_fishres_cs09_cf4_2024-05-13.rds"))

# Filtering all genes not part of clusters : the lonely genes
dr_t_no_clustr <- dr_t_ids[!(dr_t_ids$ensembl_gene_id %in% clustr_fusionres$dr_g_a_fusion$ensembl_gene_id),] 

# Filtering annotations based on enriched biological functions
# In the fishing process, the function only considers terms and pathways that are enriched. In this case, Keep rows with term_names present in cluster fusion data
dr_g_a_annots_filtr <- clustr_enrichres$dr_g_a_whole |> 
      dplyr::filter(term_name %in% clustr_fusionres$dr_g_a_fusion$term_name)
    
# Merge lonely gene data with enriched function annotation data utilizing an inner_join operation. This ensures that only rows existing in both dataframes are retained from the first dataframe. Given that multiple terms are typically linked to one gene, the relationship is designated as many-to-many.
dr_g_a_no_clustr <- dplyr::inner_join(dr_t_no_clustr, dr_g_a_annots_filtr, by = "ensembl_gene_id", relationship = "many-to-many")
    
# Select columns for fishing: "ensembl_gene_id" to fish and "term_name" for fishing. Remove duplicates.
dr_g_a_no_clustr <- dr_g_a_no_clustr |> 
      dplyr::select(ensembl_gene_id, term_name) |> 
      dplyr::distinct()
# This is the dataframe of lonely genes with Ensembl gene IDs and associated term names, susceptible to be fished into clusters.
    
## Expand clusters by fishing lonely genes sharing the same driver-GO and other (KEGG, WP) annotations as a cluster
    
# Remove "ensembl_gene_id" column to avoid conflicts, then remove duplicate rows to pass from "g_a" to "a".
dr_a_fusion_modif <- clustr_fusionres$dr_g_a_fusion |> 
      dplyr::select(-ensembl_gene_id) |> 
      dplyr::distinct()
    
# Merge modified cluster fusion data and annotated lonely gene data
dr_g_a_lonely_data <- merge(dr_g_a_no_clustr, dr_a_fusion_modif, by = "term_name")
    
    
# Get biologicaly annotated genes without clusters for the following messages
dr_g_a_no_clustr_annotated <- dr_t_ids |> 
      dplyr::filter((!ensembl_gene_id %in% clustr_fusionres$dr_g_a_fusion$ensembl_gene_id) &
                      ensembl_gene_id %in% clustr_enrichres$dr_g_a_whole$ensembl_gene_id)
    
# Get genes without clusters for the following messages
dr_g_a_no_clustr <- dr_t_ids |> 
      dplyr::filter((!ensembl_gene_id %in% clustr_fusionres$dr_g_a_fusion$ensembl_gene_id))
    

# Modify the "ensembl_transcript_id_version" column to "id" for easier merge and integration to DRomics visualisations
names(lonelyfishing_data$dr_t_c_a_fishing)[names(lonelyfishing_data$dr_t_c_a_fishing) == "ensembl_transcript_id_version"] <- "id"


# Combine DRomics info and the workflow info
b_lonely_fishres <- merge(lonelyfishing_data$dr_t_c_a_fishing, BMDres_definedCI,  by = "id")

# Only select the lonely cluster
b_only_lonely_fishres <- b_lonely_fishres |> 
  dplyr::filter(new_clustr == "Lonely")

```

## Introduction

This document is a comprehensive report, meticulously encapsulating the pivotal results derived from the DRomics analysis while detailing the workflow. It succinctly summarizes the impacts and outputs of each significant step within the pipeline, supported by visual representations like plots depicting the summary of BMD values per cluster, aiding in prioritization. Moreover, additional specific visualizations for each cluster, such as plots of fitted curves, empirical cumulative distribution function (ECDF) plots of BMD values, and summary tables, enable a more focused exploration.

This document serves as a supplementary report to the workflow_results_report, focusing on the Lonely cluster. The Lonely cluster comprises genes that remain unassociated with any other cluster throughout the workflow process.

The lonely cluster is composed of a total of `r length(unique(b_only_lonely_fishres$id))`.

Functional enrichment analysis is conducted to link the cluster with biological processes, facilitating deeper exploration of aspects potentially overlooked in the analysis.

## The Lonely cluster as an interactive table

::: fullwidth
```{r}
#| label: tbl-workflow
#| tbl-cap: "Summary table of the lonely cluster"
#| tbl-cap-location: top
#| echo: false

# Prepare the structure for the summary dataframe
b_only_lonely_fishres_summary <- data.frame(
  ensembl_transcript_id = b_only_lonely_fishres$id,
  ensembl_gene_id = b_only_lonely_fishres$ensembl_gene_id,
  external_gene_name = b_only_lonely_fishres$external_gene_name,
  NewCluster = b_only_lonely_fishres$new_clustr,
  Friendliness = b_only_lonely_fishres$friendliness,
  Term_name = b_only_lonely_fishres$term_name,
  Source = b_only_lonely_fishres$source,
  TF = b_only_lonely_fishres$TF,
  BMD.zSD = as.numeric(b_only_lonely_fishres$BMD.zSD),
  Trend = b_only_lonely_fishres$trend
  )

# Round BMD.zSD to the tenth for easier reading
b_only_lonely_fishres_summary$BMD.zSD <- round(b_only_lonely_fishres_summary$BMD.zSD, 1) 

# Remove repeated rows
b_only_lonely_fishres_summary <- unique(b_only_lonely_fishres_summary)

# Generate the interactive table 
b_only_lonely_fishres_summary |> 
  DT::datatable(options = list(pageLength = 10), class = c("compact", "hover", "row-border", "order-column")) |> 
  DT::formatStyle(columns = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), fontSize = '80%')
```
:::

 

```{r}
#| echo: false

# Switch the "id" column from "ensembl_transcript_id_version" content to "external_gene_name" content for visualizing the gene symbols

names(b_only_lonely_fishres)[names(b_only_lonely_fishres) == "id"] <- "ensembl_transcript_id_version"

names(b_only_lonely_fishres)[names(b_only_lonely_fishres) == "external_gene_name"] <- "id"

```

## Characterizing the Lonely cluster by functional enrichment

```{r}
#| echo: false

lonely_gostres <- gprofiler2::gost(
  query = b_only_lonely_fishres$ensembl_gene_id, 
  organism = "drerio", 
  ordered_query = FALSE, 
  multi_query = FALSE, 
  significant = TRUE, 
  exclude_iea = FALSE, 
  measure_underrepresentation = FALSE, 
  evcodes = TRUE, 
  user_threshold = 0.05, 
  correction_method = "fdr", 
  domain_scope = "custom_annotated",
  custom_bg = bg_t_ids$ensembl_gene_id, 
  numeric_ns = "", 
  sources = c("GO:BP", "KEGG", "WP"), 
  as_short_link = FALSE, 
  highlight = TRUE 
) 

# Transform the dataframe from "cluster per row" to "gene per row":
dr_c_a_lonely <- lonely_gostres$result |> 
      dplyr::filter(
        ((grepl("GO", source) & highlighted == TRUE) | (!(grepl("GO", source))))
      ) |> 
      dplyr::filter(
        5 <= term_size & term_size <= 500
      ) 
      dplyr::select(term_name, term_size, intersection_size, p_value, source) 
  

    
# Remove duplicate rows
dr_c_a_lonely <- unique(dr_c_a_lonely)
    
# Reset the row numbers
rownames(dr_c_a_lonely) <- NULL



```

 

| Query size                              | Background size                                    |
|--------------------------------|----------------------------------------|
| `r lonely_gostres$result$query_size[1]` | `r lonely_gostres$result$effective_domain_size[1]` |

: Number of genes involved in the query and background of the ORA {#tbl-loenrich .bordered .light}

```{r}
#| label: inter-table
#| echo: false

# Generate the interactive table 
dr_c_a_lonely |> 
  DT::datatable(options = list(pageLength = 10)) |> 
  DT::formatStyle(columns = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), fontSize = '80%')

```

 

## The results as an interactive curvesplot

> **Cluster Lonely - `r length(unique(b_only_lonely_fishres$ensembl_transcript_id_version))` transcripts**

::: panel-tabset
#### Curvesplot

```{r}
#| label: fig-curvesplot1
#| fig-cap: "DR curves for the Lonely cluster"
#| echo: false
#| message: false
#| fig-align: "center"
#| fig-asp: 0.618

# Create a curvesplot of cluster transcripts with 'cluster' identification and 'transcript count' in title
cp <- DRomics::curvesplot(
  b_only_lonely_fishres, 
  addBMD = TRUE, 
  scaling = TRUE, 
  colorby = "trend",
  npoints= 100, 
  free.y.scales = FALSE,
  xmin = 0.01, 
  xmax = 100,
  dose_log_transfo = TRUE,
  line.size = 0.5,
  line.alpha = 0.4,
  point.size = 1.5,
  point.alpha = 0.4) +
  geom_vline(xintercept = unique(f$omicdata$dose), linetype = 2, colour = "#363636", alpha = 0.7, size = 0.3) +
  xlab("Dose (µg/L)") + ylab("Signal")+
  scale_color_manual(values = c("inc" = "#1B9E77", "dec" = "#D95F02", "U" = "#7570B3", "bell" = "#E7298A")) +
  theme_light()

plotly::ggplotly(cp, tooltip = c("x", "id"))

```

#### BMDplot

```{r}
#| label: fig-bmdplot1
#| fig-cap: "BMDplot for the Lonely cluster"
#| echo: false
#| message: false
#| fig-align: "center"
#| fig-asp: 0.618

# For the bmdplots, we need to remove redundancy of rows : 

b_only_lonely_fishres_no_redund <- b_only_lonely_fishres |> 
  dplyr::select(-c(ensembl_gene_id,
                ensembl_transcript_id_version,
                TF,
                old_clustr,
                friendliness,
                term_name,
                term_id,
                source)) |> 
  dplyr::distinct()

# Create a BMDplot of cluster transcripts

bp <- DRomics::bmdplot(
  b_only_lonely_fishres_no_redund, 
  add.CI = TRUE,
  colorby = "trend",
  point.size = 2,
  point.alpha = 1,
  line.size = 0.4,
  line.alpha = 0.7,
  add.label = TRUE,
  BMD_log_transfo = TRUE) +
  xlab("BMD.zSD (μg/L)") + 
  scale_colour_manual(values = c("inc" = "#1B9E77", "dec" = "#D95F02", 
                                "U" = "#7570B3", "bell" = "#E7298A")) +
  guides(shape = "none") +
  theme_light()

plotly::ggplotly(bp, tooltip = c("x", "id"))
```
:::
